/* -*- buffer-read-only: t -*- vi: set ro:
 *
 * DO NOT EDIT THIS FILE   (Worhp_Data_Ptr_c.h)
 *
 * It has been AutoGen-ed
 * From the definitions    auto/NLP.def
 * and the template file   Worhp_Data_Ptr_c.tpl */

#ifndef HEADER_WORHP_DATA_PTR_C_H_GUARD
#define HEADER_WORHP_DATA_PTR_C_H_GUARD 1

#include "C_Worhp_Data.h"

/*
 * USAGE NOTES:
 *
 * These structures are not intended for use by C or Fortran callers;
 * those callers should usually make use of the proper (non-pointer) 
 * versions appropriate for the respective language.
 *
 * The pointer-to-members structures below are intended for use by
 * other languages (without standardised C interoperability) to work 
 * around padding and alignment issues of the non-pointer structs.
 */

typedef struct OptVarPtrStruct {
  int *n;
  int *m;
  int *k;
  int *nGPart;
  int *iGPart;
  double *F;
  double *X;
  double *XL;
  double *XU;
  double *Lambda;
  double *G;
  double *GL;
  double *GU;
  double *Mu;
  int *GPart;
  double *P;
  bool *newX;
  bool *initialised;
} OptVarPtr;

typedef struct WorkspacePtrStruct {
  FilterNode *FirstFilterNode;
  QPWorkspace *qp;
  int *DebugMarker01;
  WorhpMatrix *DF;
  WorhpMatrix *DG;
  WorhpMatrix *DL;
  WorhpMatrix *oldDL;
  WorhpMatrix *HM;
  WorhpMatrix *ID;
  WorhpMatrix *Q;
  WorhpMatrix *A;
  WorhpMatrix *C;
  WorhpMatrix *Inc;
  WorhpMatrix *CorStepsens_dxdq;
  WorhpMatrix *Bstep_RHS;
  WorhpMatrix *Bstep_dmudq;
  WorhpMatrix *BstepPerturbG;
  WorhpMatrix *BstepDx;
  WorhpMatrix *BstepDMu;
  WorhpMatrix *ZenDGp;
  WorhpMatrix *ZenDLxp;
  WorhpMatrix *ZenDLp;
  WorhpMatrix *ZenDLpp;
  WorhpMatrix *ZenDx_pDf2_rp;
  WorhpMatrix *ZenDx_rDf2_rr;
  WorhpMatrix *ZenDx_qDm_rDf2_rq;
  WorhpMatrix *ZenDm_pDf2_qp;
  WorhpMatrix *ZenDm_qDf2_qq;
  WorhpMatrix *ZenDl_pDf2_bp;
  WorhpMatrix *ZenDl_rDx_bDf2_br;
  WorhpMatrix *ZenDl_qDm_bDf2_bq;
  WorhpMatrix *ZenDl_bDf2_bb;
  WorhpMatrix *ZenDf_p;
  WorhpMatrix *ZenDf2_pp;
  WorhpMatrix *ZenDg_p;
  WorhpMatrix *ZenDg_r;
  WorhpMatrix *ZenDg_q;
  WorhpMatrix *ZenDg_b;
  WorhpQueue *QueueF;
  WorhpQueue *QueueCV;
  int *DebugMarker02;
  double *Abs_Curvature;
  double *AcceptCV;
  double *AcceptF;
  double *AcceptKKT;
  double *ArmijoAlpha;
  double *BettsActual;
  double *BettsOldRho;
  double *BettsPredicted;
  double *BettsRho;
  double *BettsSigma;
  double *BettsSumTau;
  double *BettsTau;
  double *BettsValue;
  double *BstepOldMaxCV;
  double *CorStepNormG;
  double *Curvature;
  double *Descent;
  double *F0;
  double *InActiveNormG;
  double *LowPassF;
  double *LowPassG;
  double *LowPassMerit;
  double *MeritGradient;
  double *MeritNewValue;
  double *MeritOldValue;
  double *Norm2_DX;
  double *NormMax_CV;
  double *NormMax_DL;
  double *oldF;
  double *oldNorm2_DX;
  double *oldNormMaxG;
  double *PenUpdDeltaK;
  double *PenUpdR;
  double *ScaledKKT;
  double *ScaleObj;
  double *ScaleObjQP;
  double *Alpha_Min;
  double *CVActual;
  double *CVGradient;
  double *CVPredicted;
  double *CV_Max;
  double *CV_Min;
  double *FActual;
  double *FilterDominatingCV;
  double *FilterDominatingF;
  double *FilterIntersectionCV;
  double *FPredicted;
  double *olddescent;
  double *PrevBettsTau;
  double *StartF;
  size_t *dim_SBFGS_blockval;
  size_t *dim_SBFGS_blockcsc;
  size_t *dim_SBFGS_blockcol;
  size_t *dim_SBFGS_blocksize;
  size_t *dim_SBFGS_blockstart;
  size_t *dim_SBFGS_inblock;
  size_t *dim_SBFGS_idxinblock;
  double *SBFGS_blockval;
  int *SBFGS_blockcsc;
  int *SBFGS_blockcol;
  int *SBFGS_blocksize;
  int *SBFGS_blockstart;
  int *SBFGS_inblock;
  int *SBFGS_idxinblock;
  size_t *dim_NactiveGc;
  size_t *dim_NactiveXc;
  int *NactiveGc;
  int *NactiveXc;
  size_t *dim_ZenStatus;
  size_t *dim_ZenStatus2;
  bool *ZenStatusDX;
  bool *ZenStatusDM;
  bool *ZenStatusDL;
  bool *ZenStatusDF;
  bool *ZenStatusDF2;
  bool *ZenStatusDG;
  size_t *niws;
  size_t *nrws;
  int *iws;
  double *rws;
  size_t *IWMT;
  size_t *RWMT;
  char *IWMTnames;
  char *RWMTnames;
  int *DebugMarker03;
  rwmt_index *acceptlambda;
  rwmt_index *acceptmu;
  rwmt_index *acceptx;
  iwmt_index *activeSetG;
  iwmt_index *activeSetGCorStep;
  iwmt_index *activeSetGM;
  iwmt_index *activeSetGMeq;
  iwmt_index *activeSetGMwarm;
  iwmt_index *activeSetX;
  iwmt_index *activeSetXUpDown;
  rwmt_index *CorStep_oldG;
  rwmt_index *CorStep_oldGtest;
  iwmt_index *ddg;
  iwmt_index *degree;
  rwmt_index *dfdense;
  rwmt_index *g0p;
  iwmt_index *hperm;
  iwmt_index *hperminv;
  iwmt_index *InActiveSetG;
  iwmt_index *IXLtemp;
  iwmt_index *IXUtemp;
  rwmt_index *newlambda;
  rwmt_index *newmu;
  iwmt_index *nPairgroups;
  rwmt_index *oldlambda;
  rwmt_index *oldmu;
  rwmt_index *oldx;
  rwmt_index *oldlambdaCorStep;
  rwmt_index *oldmuCorStep;
  rwmt_index *oldxCorStep;
  iwmt_index *Pairgroups;
  rwmt_index *penalty;
  rwmt_index *penmu;
  rwmt_index *qpdx;
  rwmt_index *qpeqlm;
  rwmt_index *qpeqrhs;
  rwmt_index *qpielm;
  rwmt_index *qpierhs;
  iwmt_index *qppos;
  rwmt_index *RelaxDelta;
  rwmt_index *RelaxPen;
  rwmt_index *RelaxPenTemp;
  iwmt_index *Relentries;
  iwmt_index *Relvars;
  rwmt_index *saveDF;
  rwmt_index *saveDG;
  rwmt_index *savexp;
  rwmt_index *scalecona;
  rwmt_index *scaleconc;
  rwmt_index *scaleconaWAS;
  rwmt_index *scaleconcWAS;
  rwmt_index *sensderivative;
  rwmt_index *oldg;
  rwmt_index *oldqpdx;
  rwmt_index *WARMSALL;
  rwmt_index *WARMSLALL;
  rwmt_index *WARMSUALL;
  rwmt_index *WARMZALL;
  rwmt_index *WARMZLALL;
  rwmt_index *WARMZUALL;
  rwmt_index *XLtemp;
  rwmt_index *XUtemp;
  counter *AcceptMajorIter;
  counter *Calls;
  counter *CorStepIter;
  counter *CorStepSDCount;
  counter *ForceIter;
  counter *InteractiveStep;
  counter *InteractiveLastCmd;
  counter *MajorIter;
  counter *MinorIter;
  counter *NextAres;
  counter *RCCounter;
  counter *RCCounter2;
  counter *RCCounter3;
  counter *RCCounter4;
  counter *LScounter;
  int *blocknnz;
  int *boxLDIM;
  int *boxUDIM;
  int *CurrentFeasMode;
  int *NactiveG;
  int *NactiveGNLP;
  int *nbcol;
  int *nblock;
  int *nEQ;
  int *nEQbox;
  int *nEQgen;
  int *nIE;
  int *nIEbox;
  int *nIEboxUpper;
  int *nIEboxLower;
  int *nIEgen;
  int *nIEgenLower;
  int *nIEgenUpper;
  int *nIEgenLowerUpper;
  int *nQP;
  int *RelaxNvar;
  int *nFilterEntries;
  bool *AcceptFeasible;
  bool *AcceptOptimal;
  bool *AcceptSolFound;
  bool *AutoQPRecActive;
  bool *BettsUpdate;
  bool *Complementary;
  bool *Constrained;
  bool *BstepFeasActive;
  bool *BstepFeasFinished;
  bool *BstepSuccessful;
  bool *BstepFirstArmijoCall;
  bool *CorStepInitialised;
  bool *CorStepQPActive;
  bool *CorStepRelaxPre;
  bool *CorStepQPFailed;
  bool *DGslcDone;
  bool *Feasible;
  bool *FeasibleInit;
  bool *FeasibleInitFailed;
  bool *FeasibleInitDone;
  bool *FeasibleStep;
  bool *FirstIteration;
  bool *HMposdef;
  bool *HMslcDone;
  bool *InitialLMEst;
  bool *KKTok;
  bool *Optimal;
  bool *QPNotFinished;
  bool *RelaxCon;
  bool *scaledObj;
  bool *scaledQP;
  bool *setInactive;
  bool *TakeQPSolError;
  bool *UseId;
  bool *WasFeasMode;
  bool *Acceptable;
  bool *AresForce;
  bool *AugmentFilter;
  bool *CheckFullStepsize;
  bool *FeasRest;
  bool *FirstHessianReg;
  bool *FullStepsize;
  bool *FStepsize;
  bool *RejectedByFilter;
  bool *SecondHessianReg;
  bool *SLPstep;
  bool *SmallerAlpha;
  bool *SwitchingCond;
  int *DebugMarker04;
  bool *initialised;
} WorkspacePtr;

typedef struct ParamsPtrStruct {
  QPParams *qp;
  int *DebugMarker05;
  double *AcceptTolFeas;
  double *AcceptTolOpti;
  double *ArmijoBeta;
  double *ArmijoMaxAlpha;
  double *ArmijoMinAlpha;
  double *ArmijoMinAlphaRec;
  double *ArmijoSigma;
  double *BettsFactor;
  double *BettsPoint;
  double *BoundTolFac;
  double *CorStepBettsSum;
  double *CorStepConvio;
  double *CorStepConStop;
  double *CorStepPFactor;
  double *CorStepPMax;
  double *CheckFJ;
  double *CurvBCond;
  double *CurvBFac;
  double *CurvCond;
  double *CurvFac;
  double *FeasibleInitTol;
  double *FidifEps;
  double *FocusOnFeasFactor;
  double *Infty;
  double *InftyUnbounded;
  double *LMestQPipComTol;
  double *LMestQPipResTol;
  double *LowPassAlphaF;
  double *LowPassAlphaG;
  double *LowPassAlphaMerit;
  double *MA97small;
  double *MA97u;
  double *MeritGradTol;
  double *PenUpdEpsKFac;
  double *PenUpdEpsBar;
  double *PenUpdMaxDeltaK;
  double *PenUpdMaxFac;
  double *PenUpdRBar;
  double *PrecisionF;
  double *PrecisionG;
  double *QPscaleParam;
  double *RelaxMaxDelta;
  double *RelaxMaxPen;
  double *RelaxRho;
  double *RelaxStart;
  double *ScaleFacObj;
  double *ScaleFacQP;
  double *StartBettsTau;
  double *Timeout;
  double *TolComp;
  double *TolFeas;
  double *TolOpti;
  double *TolWeakActive;
  double *TooBigCV;
  double *TooBigKKT;
  double *eps;
  double *IncreaseIWS;
  double *IncreaseRWS;
  double *FilterGammaCV;
  double *FilterGammaF;
  double *GammaAlpha;
  double *IncBettsTau;
  double *IncBettsTauMore;
  double *MinBettsTau;
  double *ReduceBettsTau;
  double *RefineStartTol;
  double *RefineMaxRelax;
  double *RefineMaxHMReg;
  double *SwitchingDelta;
  double *SwitchingSF;
  double *SwitchingSCV;
  int *Ares;
  int *BFGSmethod;
  int *BFGSrestart;
  int *BFGSmaxblockSize;
  int *BFGSminblockSize;
  int *CorStepMaxIter;
  int *CorStepMethod;
  int *CorStepMode;
  int *GroupMethod;
  int *LogLevel;
  int *LogResult;
  int *MA97ordering;
  int *MA97scaling;
  int *MA97print;
  int *MA97nemin;
  int *MaxCalls;
  int *MaxForce;
  int *MaxGPart;
  int *MaxIter;
  int *MeritFunction;
  int *NLPmethod;
  int *NLPprint;
  int *PairMethod;
  int *PenUpdEpsKSequence;
  int *UserHMstructure;
  int *MaxLScounter;
  int *RegStrategy;
  bool *AutoQPRecovery;
  bool *CheckStructureDF;
  bool *CheckStructureDG;
  bool *CheckStructureHM;
  bool *CorStepRecoveryDX;
  bool *FGtogether;
  bool *FJandND;
  bool *FeasibleDual;
  bool *FeasibleInit;
  bool *FeasibleOnly;
  bool *FidifHM;
  bool *FirstDifCentral;
  bool *FocusOnFeas;
  bool *InitialLMest;
  bool *KeepAcceptableSol;
  bool *LinMult;
  bool *LowPassFilter;
  bool *MA97blas3;
  bool *MA97mf;
  bool *MatrixCC;
  bool *MoreRelax;
  bool *QuadraticProblem;
  bool *RefineFeasibility;
  bool *RefineOnlyOnAlpha;
  bool *RestUntilFeas;
  bool *ScaleConIter;
  bool *ScaledFD;
  bool *ScaledKKT;
  bool *ScaledObj;
  bool *ScaledQP;
  bool *TakeQPSol;
  bool *TooBig;
  bool *UpdateMu;
  bool *UserDF;
  bool *UserDG;
  bool *UserHM;
  bool *UserZenDGp;
  bool *UserZenDLxp;
  bool *UserZenDLp;
  bool *UserZenDLpp;
  bool *UseZen;
  bool *ZenCheckMaxPert;
  bool *ZenRenewLU;
  bool *ZenFDnewMethod;
  bool *WeakActiveSet;
  bool *AlphaMinConst;
  bool *IgnoreFilterCrit;
  bool *FilterBisecAlpha;
  bool *FilterIntersecAlpha;
  bool *MaxNorm;
  bool *ReinitFilter;
  int *DebugMarker06;
  int *internalParChanged;
  bool *initialised;
} ParamsPtr;

typedef struct ControlPtrStruct {
  DateType *Date;
  TimerType *Timer;
  int *Stage;
  bool *UserAction;
  int *status;
  int *int_status;
  int *pre_zen_status;
  int *currentStage;
  counter *ZenRCcounter1;
  counter *ZenRCcounter2;
  bool *ZenInit;
  bool *initialised;
} ControlPtr;



/*
 * Populates the OptVarPtr struct.
 * Calling it with p == NULL returns the size of OptVarPtr,
 * otherwise populates p with the addresses of the opt members.
 */
DLL_PUBLIC int SetOptVarPtr (OptVar *const opt, OptVarPtr *const p);

/*
 * Populates the WorkspacePtr struct.
 * Calling it with p == NULL returns the size of WorkspacePtr,
 * otherwise populates p with the addresses of the wsp members.
 */
DLL_PUBLIC int SetWorkspacePtr (Workspace *const wsp, WorkspacePtr *const p);

/*
 * Populates the ParamsPtr struct.
 * Calling it with p == NULL returns the size of ParamsPtr,
 * otherwise populates p with the addresses of the par members.
 */
DLL_PUBLIC int SetParamsPtr (Params *const par, ParamsPtr *const p);

/*
 * Populates the ControlPtr struct.
 * Calling it with p == NULL returns the size of ControlPtr,
 * otherwise populates p with the addresses of the cnt members.
 */
DLL_PUBLIC int SetControlPtr (Control *const cnt, ControlPtr *const p);


#endif /* HEADER_WORHP_DATA_PTR_C_H_GUARD */


