/* -*- buffer-read-only: t -*- vi: set ro:
 *
 * DO NOT EDIT THIS FILE   (C_Worhp_Data.h)
 *
 * It has been AutoGen-ed
 * From the definitions    auto/NLP.def
 * and the template file   C_Worhp_Data.tpl */

#include <stdlib.h> /* For size_t */

#ifndef HEADER_C_WORHP_DATA_H_GUARD
#define HEADER_C_WORHP_DATA_H_GUARD 1

#include "C_std.h"
#include "worhp_STL_c.h"
#include "C_cs.h"
#include "C_timer.h"
#include "C_qp_data.h"
#include "C_filter_data.h"

#define PATCH_STRING_LENGTH 8

extern const int worhp_major;
extern const int worhp_minor;
extern const char worhp_patch[PATCH_STRING_LENGTH];

extern const int nMemberOptVar;
extern const int nMemberWorkspace;
extern const int nMemberParams;
extern const int nMemberControl;

/* Used in conditional for allocating the opt->G members. */
extern const int minM;

enum { 
 /*----------------------------------------------------------------- 
  *  Array sizes
  *-----------------------------------------------------------------*/ 
  WMTslices = 100,
  WMTrows = 6,
  WMTnames = 20,
  NAres = 7,
  NUserAction = 14,
  NStageHistory = 10,
 /*----------------------------------------------------------------- 
  *  Feasibility mode flags
  *-----------------------------------------------------------------*/ 
  FEAS_MODE_OFF = 0,
  FEAS_MODE_INITIAL = 1,
 /* was: JustFeasible */
  FEAS_MODE_NOOBJ = 2,
 /* was: FeasModeActive */
  FEAS_MODE_DUAL = 4,
 /*----------------------------------------------------------------- 
  *  Zen RC flags
  *-----------------------------------------------------------------*/ 
  Zen_RC_Init = 0,
  Zen_RC_Renew_LU = 1,
  Zen_RC_DGp = 2,
  Zen_RC_DLp = 3,
  Zen_RC_DLxp = 4,
  Zen_RC_DLpp = 5,
 /*----------------------------------------------------------------- 
  *  User action constants
  *-----------------------------------------------------------------*/ 
  callWorhp = 1,
  evalF = 2,
  evalG = 3,
  evalDF = 4,
  evalDG = 5,
  evalHM = 6,
  evalZenDGp = 7,
  evalZenDLxp = 8,
  evalZenDLp = 9,
  evalZenDLpp = 10,
  iterOutput = 11,
  fidif_DF = 12,
  fidif_DG = 13,
  fidif_HM = 14,
 /* Not actually a user action, but a combination of all fidif_* */
  fidif = 15,
 /*----------------------------------------------------------------- 
  *  SQP status constants
  *-----------------------------------------------------------------*/ 
 /* 1st call to SQP */
  FirstCall = 20,
 /* SQP is iterating */
  Iterating = 21,
 /* SQP is iterating */
  IteratingAres = 22,
 /* 1st Armijo call in current major iter */
  ArmijoFirstCall = 23,
 /* Armijo updates x and flags user action */
  ArmijoUpdate = 24,
 /* Armijo evaluates merit function */
  ArmijoEvaluate = 25,
 /* QP solver wants to try an SLP step */
  SolverSLP = 26,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_start = 27,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_fi = 28,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_fij = 29,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_fdiag = 30,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_gi = 31,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_hgr = 32,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_hgrsgr = 33,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_gij = 34,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_gdiag = 35,
 /* Setting up Zen */
  ZenSetup = 36,
 /* CorStep is iterating */
  CorStepIterating = 37,
 /*----------------------------------------------------------------- 
  *  Armijo recovery strategies
  *-----------------------------------------------------------------*/ 
 /* Armijo recovery strategy: SLP step */
  AresSLP = 41,
 /* Armijo recovery strategy: Non-monotone */
  AresNonMon = 42,
 /* Armijo recovery strategy: Force 1 */
  AresForce = 43,
 /* Armijo recovery strategy: Switch to dual-feas-mode */
  AresFeas = 44,
 /* Give up */
  AresGiveUp = 50,
 /*----------------------------------------------------------------- 
  *  SQP stages
  *-----------------------------------------------------------------*/ 
  No_Stage = 100,
  Init_SQP = 101,
  Pre_KKT = 102,
  Check_KKT = 103,
  Create_QP = 104,
  Hessian_Regularisation = 105,
  Solve_QP = 106,
  Post_QP = 107,
  Find_Stepsize = 108,
  Update_Point = 109,
  Pre_CorStep = 110,
  CorStepcon = 111,
  Recovery_Strategies = 112,
  Finalise = 113,
  SLP_step = 114,
  Solve_Feasibility_QP = 115,
  Post_Optimum = 116,
  Pre_BStep = 117,
  BStep = 118,
 /*----------------------------------------------------------------- 
  *  (somehow) successful termination
  *-----------------------------------------------------------------*/ 
  TerminateSuccess = 1000,
  OptimalSolution = 1001,
 /* IER = 1 */
  SearchDirectionZero = 1002,
 /* IER = 2 */
  SearchDirectionSmall = 1003,
 /* IER = 3 */
  StationaryPointFound = 1004,
  AcceptableSolution = 1005,
  AcceptablePrevious = 1006,
  FritzJohn = 1007,
  NotDiffable = 1008,
  Unbounded = 1009,
  FeasibleSolution = 1010,
  LowPassFilterOptimal = 1011,
  LowPassFilterAcceptable = 1012,
  OptimalSolutionBoxEqual = 1013,
 /*----------------------------------------------------------------- 
  *  (somehow) unsuccessful termination
  *-----------------------------------------------------------------*/ 
  TerminateError = -1000,
  InitError = -1001,
  DataError = -1002,
  MaxCalls = -1003,
 /* IER = 4 */
  MaxIter = -1004,
 /* IER = -3 */
  MinimumStepsize = -1006,
 /* IER < -10 */
  QPerror = -1007,
 /* IER = 6 */
  ProblemInfeasible = -1008,
  GroupsComposition = -1009,
  TooBig = -1010,
  evalsNaN = -1011,
  Timeout = -1012,
  FDError = -1013,
  LocalInfeas = -1014,
  LicenseError = -1015,
  LicenseWarnExpiryDays = 31,
  TerminatedByUser = -1020,
  FunctionErrorF = -1100 - 2,
  FunctionErrorG = -1100 - 3,
  FunctionErrorDF = -1100 - 4,
  FunctionErrorDG = -1100 - 5,
  FunctionErrorHM = -1100 - 6
};


typedef struct OptVarStruct {
  int n;
  int m;
  int k;
  int nGPart;
  int iGPart;
  double F;
  double *X;
  double *XL;
  double *XU;
  double *Lambda;
  double *G;
  double *GL;
  double *GU;
  double *Mu;
  int *GPart;
  double *P;

 /* Indicates that X was changed by WORHP */ 
  bool newX;

 /* Automatically added initialisation flag.  */
  bool initialised;
} OptVar;

typedef struct WorkspaceStruct {

 /*------------------------------------------------ 
  *  Filter nodes
  *------------------------------------------------ */ 
  FilterNode *FirstFilterNode;

 /*------------------------------------------------ 
  *  QP Workspace
  *------------------------------------------------ */ 
  QPWorkspace qp;

 /* Debug marker. Used to find memory alignment/padding issues */ 
  int DebugMarker01;

 /*------------------------------------------------ 
  *  Matrices
  *------------------------------------------------ */ 
  WorhpMatrix DF;
  WorhpMatrix DG;
  WorhpMatrix DL;
  WorhpMatrix oldDL;
  WorhpMatrix HM;
  WorhpMatrix ID;
  WorhpMatrix Q;
  WorhpMatrix A;
  WorhpMatrix C;

 /* Incidence matrix for group algorithms */ 
  WorhpMatrix Inc;

 /* Sensitivity derivative for correction step dx/dq. */ 
  WorhpMatrix CorStepsens_dxdq;

 /* RHS for calculation of sensitivity for correction step. */ 
  WorhpMatrix Bstep_RHS;

 /* Sensitivity derivative for correction step dmu/dq. */ 
  WorhpMatrix Bstep_dmudq;

 /* Perturbation for sensitivity analysis in correction step. */ 
  WorhpMatrix BstepPerturbG;

 /* Search direction in correction step. */ 
  WorhpMatrix BstepDx;

 /* Search direction for lagrangian multipliers in correction step. */ 
  WorhpMatrix BstepDMu;

 /* Derivative DG_P for post analysis */ 
  WorhpMatrix ZenDGp;

 /* Derivative DL_XP (Lagrangian) for post analysis */ 
  WorhpMatrix ZenDLxp;

 /* Derivative DL_P (Lagrangian) for post analysis */ 
  WorhpMatrix ZenDLp;

 /* Derivative DL_PP (Lagrangian) for post analysis */ 
  WorhpMatrix ZenDLpp;

 /* Sensitivity derivatives dx/dp, d^2f/(dr*dq). */ 
  WorhpMatrix ZenDx_pDf2_rp;

 /* Sensitivity derivatives dx/dr, d^2f/dr^2. Symmetric. */ 
  WorhpMatrix ZenDx_rDf2_rr;

 /* Sensitivity derivative dx/dq, (dmu/dr)^T, d^2f/(dr*dq). */ 
  WorhpMatrix ZenDx_qDm_rDf2_rq;

 /* Sensitivity derivative dmu/dp, d^2f/(dq*dp). */ 
  WorhpMatrix ZenDm_pDf2_qp;

 /* Sensitivity derivative dmu/dq, df^2/dq^2. Symmetric. */ 
  WorhpMatrix ZenDm_qDf2_qq;

 /* Sensitivity derivative dlambda/dp, d^2f/(db*dp). */ 
  WorhpMatrix ZenDl_pDf2_bp;

 /* Sensitivity derivative (dx/db)^T, dlambda/dr, d^2f/(db*dr). */ 
  WorhpMatrix ZenDl_rDx_bDf2_br;

 /* Sensitivity derivative (dmu/db)^T, dlambda/dq, d^2f/(db*dq). */ 
  WorhpMatrix ZenDl_qDm_bDf2_bq;

 /* Sensitivity derivative dlambda/db, d^2f/db^2. Symmetric. */ 
  WorhpMatrix ZenDl_bDf2_bb;

 /* Sensitivity derivative df/dp. Vector. */ 
  WorhpMatrix ZenDf_p;

 /* Sensitivity derivative d^2f/dp^2. Symmetric. */ 
  WorhpMatrix ZenDf2_pp;

 /* Sensitivity derivative dg/dp. */ 
  WorhpMatrix ZenDg_p;

 /* Sensitivity derivative dg/dr. */ 
  WorhpMatrix ZenDg_r;

 /* Sensitivity derivative dg/dq. */ 
  WorhpMatrix ZenDg_q;

 /* Sensitivity derivative dg/db. */ 
  WorhpMatrix ZenDg_b;

 /* FIFO for F values */ 
  WorhpQueue QueueF;

 /* FIFO for constraint violations */ 
  WorhpQueue QueueCV;

 /* Debug marker. Used to find memory alignment/padding issues */ 
  int DebugMarker02;

 /*------------------------------------------------ 
  *  Reals
  *------------------------------------------------ */ 

 /* = |dT*H*d|                           [SCAL] */ 
  double Abs_Curvature;

 /* CV value of best-so-far acceptable solution */ 
  double AcceptCV;

 /* F value of best-so-far acceptable solution */ 
  double AcceptF;

 /* KKT value of best-so-far acceptable solution */ 
  double AcceptKKT;

 /* Armijo stepsize                      [ALPHA] */ 
  double ArmijoAlpha;

 /* Betts-update parameter               [ACTUAL] */ 
  double BettsActual;

 /* Betts-update parameter               [OLDRHO] */ 
  double BettsOldRho;

 /* Betts-update parameter               [PRDTED] */ 
  double BettsPredicted;

 /* Used for calculating the Bettsupdate */ 
  double BettsRho;

 /* Betts-update parameter */ 
  double BettsSigma;

 /* Sum of Betts-update parameter for AutoQPRecovery */ 
  double BettsSumTau;

 /* Betts-update parameter               [TAU] */ 
  double BettsTau;

 /* Betts-update: Value added to HM diag */ 
  double BettsValue;

 /* Maximum constraint violation at uncorrected next iterate */ 
  double BstepOldMaxCV;

 /* CorStep: 2-Norm of the vector of constraint violations */ 
  double CorStepNormG;

 /* = dT*H*d */ 
  double Curvature;

 /* df^T*d */ 
  double Descent;

 /* RC value F0 */ 
  double F0;

 /* 2-Norm of the vector of inactive constraint violations */ 
  double InActiveNormG;

 /* Lowpass filter value for F */ 
  double LowPassF;

 /* Lowpass filter value for G */ 
  double LowPassG;

 /* Lowpass filter value for the merit function */ 
  double LowPassMerit;

 /* Derivative of merit function         [FAC] */ 
  double MeritGradient;

 /* New value of merit function        [VAXLK] */ 
  double MeritNewValue;

 /* Old value of merit function        [VAL] */ 
  double MeritOldValue;

 /* 2-norm of QP search direction        [NRMDX] */ 
  double Norm2_DX;

 /* Max-norm of Constraints Violation    [NRMNB] */ 
  double NormMax_CV;

 /* Max-norm of Gradient of Lagrangian   [NRMGRD] */ 
  double NormMax_DL;

 /* old value of F */ 
  double oldF;

 /* old 2-norm of QP search direction */ 
  double oldNorm2_DX;

 /* old NormMax value of G */ 
  double oldNormMaxG;

 /* penalty parameter update             [DELTAK] */ 
  double PenUpdDeltaK;

 /* penalty parameter update             [R] */ 
  double PenUpdR;

 /* New KKT value (sKKT or KKT) */ 
  double ScaledKKT;

 /* Scaling for the objective function */ 
  double ScaleObj;

 /* Scaling for the objective function for the QP */ 
  double ScaleObjQP;

 /* Minimal trial stepsize. */ 
  double Alpha_Min;

 /* Betts-update parameter. */ 
  double CVActual;

 /* Derivative of constraint violation. */ 
  double CVGradient;

 /* Betts-update parameter. */ 
  double CVPredicted;

 /* Maximal CV for the initialization of the filter. */ 
  double CV_Max;

 /* If CV < CV_Min check the the switching condition. */ 
  double CV_Min;

 /* Betts-update parameter. */ 
  double FActual;

 /* Constraint violation value of the filter entry which dominates the trial iterate. */ 
  double FilterDominatingCV;

 /* Objective function value of the filter entry which dominates the trial iterate. */ 
  double FilterDominatingF;

 /* Constraint violation value at the intersection of the filter envelope with the line that connects the previous iterate with the current trial iterate. */ 
  double FilterIntersectionCV;

 /* Betts-update parameter. */ 
  double FPredicted;

 /* Original df^T*d for accelerating heuristic (ignore criteria). */ 
  double olddescent;

 /* Betts-update parameter. */ 
  double PrevBettsTau;

 /* Initial value of the objective function. */ 
  double StartF;

 /*------------------------------------------------ 
  *  Variable size arrays
  *------------------------------------------------ */ 
  size_t dim_SBFGS_blockval;
  size_t dim_SBFGS_blockcsc;
  size_t dim_SBFGS_blockcol;
  size_t dim_SBFGS_blocksize;
  size_t dim_SBFGS_blockstart;
  size_t dim_SBFGS_inblock;
  size_t dim_SBFGS_idxinblock;

 /* values of SBFGS blocks */ 
  double *SBFGS_blockval;

 /* CS column vector for SBFGS */ 
  int *SBFGS_blockcsc;

 /* CC column vector for SBFGS */ 
  int *SBFGS_blockcol;

 /* size of SBFGS blocks */ 
  int *SBFGS_blocksize;

 /* vector of first columns for SBFGS */ 
  int *SBFGS_blockstart;

 /* index vector for SBFGS */ 
  int *SBFGS_inblock;

 /* index vector for SBFGS */ 
  int *SBFGS_idxinblock;
  size_t dim_NactiveGc;
  size_t dim_NactiveXc;

 /* cumulated number of active constraints */ 
  int *NactiveGc;

 /* cumulated number of active box constraints */ 
  int *NactiveXc;
  size_t dim_ZenStatus;
  size_t dim_ZenStatus2;

 /* Calculation status of sensitivity derivatives of x */ 
  bool *ZenStatusDX;

 /* Calculation status of sensitivity derivatives of mu */ 
  bool *ZenStatusDM;

 /* Calculation status of sensitivity derivatives of lambda */ 
  bool *ZenStatusDL;

 /* Calculation status of sensitivity derivatives of f */ 
  bool *ZenStatusDF;

 /* Calculation status of sensitivity derivatives of f */ 
  bool *ZenStatusDF2;

 /* Calculation status of sensitivity derivatives of g */ 
  bool *ZenStatusDG;

 /*------------------------------------------------ 
  *  Workspace stuff
  *------------------------------------------------ */ 
  size_t niws;
  size_t nrws;
  int *iws;
  double *rws;
  size_t IWMT[WMTrows][WMTslices];
  size_t RWMT[WMTrows][WMTslices];
  char IWMTnames[WMTnames][WMTslices];
  char RWMTnames[WMTnames][WMTslices];

 /* Debug marker. Used to find memory alignment/padding issues */ 
  int DebugMarker03;

 /*------------------------------------------------ 
  *  WMT indices
  *------------------------------------------------ */ 

 /* Values of LAMBDA of the last acceptable solution */ 
  rwmt_index acceptlambda;

 /* Values of Mu of the last acceptable solution */ 
  rwmt_index acceptmu;

 /* Values of X of the last acceptable solution */ 
  rwmt_index acceptx;

 /* Active Set flags for G */ 
  iwmt_index activeSetG;

 /* Active Set flags from the last solved qp */ 
  iwmt_index activeSetGCorStep;

 /* Index of the QP inequality constraints LM in the general problem */ 
  iwmt_index activeSetGM;

 /* Index of the QP equality constraints LM in the general problem */ 
  iwmt_index activeSetGMeq;

 /* Index of the QP inequality constraints LM for qp warmstart */ 
  iwmt_index activeSetGMwarm;

 /* Active Set flags for X */ 
  iwmt_index activeSetX;

 /* Active Set flags for X */ 
  iwmt_index activeSetXUpDown;

 /* Violation in the constraints before CorStep */ 
  rwmt_index CorStep_oldG;

 /* Violation in the constraints before CorStep */ 
  rwmt_index CorStep_oldGtest;

 /* structure of Hessian without f */ 
  iwmt_index ddg;

 /* for realsparse BFGS */ 
  iwmt_index degree;

 /* DF as dense vector                   [LGRAD] */ 
  rwmt_index dfdense;

 /* RC Pointer to g0 */ 
  rwmt_index g0p;

 /* Hessian (symmetric) permutation vector */ 
  iwmt_index hperm;

 /* Hessian inverse (symmetric) permutation vector */ 
  iwmt_index hperminv;

 /* Inactive Set indicies for G */ 
  iwmt_index InActiveSetG;

 /* Used for building the box constraints */ 
  iwmt_index IXLtemp;

 /* Used for building the box constraints */ 
  iwmt_index IXUtemp;

 /* New Box LMs                          [LQLAM] */ 
  rwmt_index newlambda;

 /* New Non-box LMs                      [LQLAM] */ 
  rwmt_index newmu;

 /* vector of number of pairgroups */ 
  iwmt_index nPairgroups;

 /* Original LAMBDA for Armijo */ 
  rwmt_index oldlambda;

 /* Original MU for Armijo */ 
  rwmt_index oldmu;

 /* Original X for Armijo */ 
  rwmt_index oldx;

 /* Original LAMBDA for CorStep */ 
  rwmt_index oldlambdaCorStep;

 /* Original MU for CorStep */ 
  rwmt_index oldmuCorStep;

 /* Original X for CorStep */ 
  rwmt_index oldxCorStep;

 /* vector of pairgroups memberships     [hm%nnz] */ 
  iwmt_index Pairgroups;

 /* Penalty parameters                   [LPEN] */ 
  rwmt_index penalty;

 /* LMs for penalty parameter update     [LPPADD] */ 
  rwmt_index penmu;

 /* Search direction from QP             [LQX] */ 
  rwmt_index qpdx;

 /* LMs of equalities                    [LQMU] */ 
  rwmt_index qpeqlm;

 /* RHS of equalities                    [LQRSEQ] */ 
  rwmt_index qpeqrhs;

 /* LMs of inequalities                  [LQRLAM] */ 
  rwmt_index qpielm;

 /* RHS of inequalities                  [LQRSIE] */ 
  rwmt_index qpierhs;

 /* POS array for QPDATA                 [CONPOS] */ 
  iwmt_index qppos;

 /* constraint relaxation variables      [DELTA] */ 
  rwmt_index RelaxDelta;

 /* constraint relaxation penaltys       [RDELTA] */ 
  rwmt_index RelaxPen;

 /* temporary constraint relaxation penaltys */ 
  rwmt_index RelaxPenTemp;

 /* vector of relevant entries           [opt%m] */ 
  iwmt_index Relentries;

 /* vector of relevant variables         [opt%n] */ 
  iwmt_index Relvars;

 /* Copy of DFval for FD */ 
  rwmt_index saveDF;

 /* Copy of DGval for FD */ 
  rwmt_index saveDG;

 /* RC Pointer to savex */ 
  rwmt_index savexp;

 /* Vector of scaling factors for the eq. constraints */ 
  rwmt_index scalecona;

 /* Vector of scaling factors for the ie. constraints */ 
  rwmt_index scaleconc;

 /* Vector of scaling factors for the eq. constraints */ 
  rwmt_index scaleconaWAS;

 /* Vector of scaling factors for the ie. constraints */ 
  rwmt_index scaleconcWAS;

 /* Sensitivity derivative used for computing CorStep */ 
  rwmt_index sensderivative;

 /* Original G for Armijo */ 
  rwmt_index oldg;

 /* Original qpdx for accelerating heuristic (ignore criteria). */ 
  rwmt_index oldqpdx;

 /* WARMSALL for QP warmstart */ 
  rwmt_index WARMSALL;

 /* WARMSLALL for QP warmstart */ 
  rwmt_index WARMSLALL;

 /* WARMSUALL for QP warmstart */ 
  rwmt_index WARMSUALL;

 /* WARMSALL for QP warmstart */ 
  rwmt_index WARMZALL;

 /* WARMSLALL for QP warmstart */ 
  rwmt_index WARMZLALL;

 /* WARMSUALL for QP warmstart */ 
  rwmt_index WARMZUALL;

 /* Used for building the box constraints */ 
  rwmt_index XLtemp;

 /* Used for building the box constraints */ 
  rwmt_index XUtemp;

 /*------------------------------------------------ 
  *  Counters
  *------------------------------------------------ */ 

 /* MajorIter corresponding to AcceptMerit */ 
  counter AcceptMajorIter;

 /* Counter: WORHP calls */ 
  counter Calls;

 /* Counter: Corstep iterations */ 
  counter CorStepIter;

 /* Counter for sensitivity derivatives */ 
  counter CorStepSDCount;

 /* Iteration counter for force steps */ 
  counter ForceIter;

 /* Counter for stepping through solver calls */ 
  counter InteractiveStep;

 /* Last command in interactive mode */ 
  counter InteractiveLastCmd;

 /* Counter: major (= SQP) iterations */ 
  counter MajorIter;

 /* Counter: minor (= QP) iterations */ 
  counter MinorIter;

 /* Next Armijo recovery strategy to be used */ 
  counter NextAres;

 /* Counter for loops with Reverse Communication */ 
  counter RCCounter;

 /* Counter for loops with Reverse Communication */ 
  counter RCCounter2;

 /* Counter for loops with Reverse Communication */ 
  counter RCCounter3;

 /* Counter for loops with Reverse Communication */ 
  counter RCCounter4;

 /* Counter: Check whether accelerating heuristics would help. */ 
  counter LScounter;

 /*------------------------------------------------ 
  *  Dimensions and element counts
  *------------------------------------------------ */ 
  int blocknnz;
  int boxLDIM;
  int boxUDIM;

 /* Currently active feasibility mode */ 
  int CurrentFeasMode;

 /* Number of active general constraints */ 
  int NactiveG;

 /* Number of active NLP constraints */ 
  int NactiveGNLP;
  int nbcol;
  int nblock;

 /* number of equality constraints */ 
  int nEQ;

 /* number of equality box constraints */ 
  int nEQbox;

 /* number of equality non-box constraints */ 
  int nEQgen;

 /* number of inequality constraints */ 
  int nIE;

 /* number of inequality box constraints */ 
  int nIEbox;

 /* number of upper inequality box constraints */ 
  int nIEboxUpper;

 /* number of lower inequality box constraints */ 
  int nIEboxLower;

 /* number of inequality non-box constraints */ 
  int nIEgen;

 /* number of lower inequality general constraints */ 
  int nIEgenLower;

 /* number of upper inequality general constraints */ 
  int nIEgenUpper;

 /* number of general inequality constraints bounded from both sides */ 
  int nIEgenLowerUpper;

 /* Number of variables for QP */ 
  int nQP;

 /* Number of constraint relaxation variables */ 
  int RelaxNvar;

 /* Maximum Number of Filter Entries */ 
  int nFilterEntries;

 /*------------------------------------------------ 
  *  Logicals
  *------------------------------------------------ */ 

 /* Current point feasible to acceptable tol.? */ 
  bool AcceptFeasible;

 /* Current point optimal to acceptable tol.? */ 
  bool AcceptOptimal;

 /* Found an acceptable solution? */ 
  bool AcceptSolFound;

 /* Automatic QP Recovery Active? */ 
  bool AutoQPRecActive;

 /* Do Betts' update */ 
  bool BettsUpdate;

 /* Complementarity conditions satisfied? */ 
  bool Complementary;

 /* Problem has constraints on G  <=>  M > 0 */ 
  bool Constrained;

 /* sge - Correction step due to perturbed constraints is active */ 
  bool BstepFeasActive;

 /* sge - Flag showing that correction via feasibility finished */ 
  bool BstepFeasFinished;

 /* sge - Correction step was successful */ 
  bool BstepSuccessful;

 /* sge - Correction step not yet initialised, but first call to armijo */ 
  bool BstepFirstArmijoCall;

 /* Correction step for the QP active */ 
  bool CorStepInitialised;

 /* Correction step for the QP active */ 
  bool CorStepQPActive;

 /* Prediction for relax penalty done? */ 
  bool CorStepRelaxPre;

 /* Correction step for the QP failed */ 
  bool CorStepQPFailed;

 /* DGslc has been constructed */ 
  bool DGslcDone;

 /* Current point feasible? */ 
  bool Feasible;

 /* FeasibleInit shall be used */ 
  bool FeasibleInit;

 /* FeasibleInit has failed */ 
  bool FeasibleInitFailed;

 /* FeasibleInit mode has been completed */ 
  bool FeasibleInitDone;

 /* Focus on feasibility? */ 
  bool FeasibleStep;

 /* First iteration? */ 
  bool FirstIteration;

 /* Hessian guaranteed as positive definite */ 
  bool HMposdef;

 /* HMslc has been constructed */ 
  bool HMslcDone;

 /* Do estimation for LM? */ 
  bool InitialLMEst;

 /* KKT conditions satisfied? */ 
  bool KKTok;

 /* Current point optimal? */ 
  bool Optimal;

 /* Intermediate QP solution used? */ 
  bool QPNotFinished;

 /* Do constraint relaxation in QP?      [LIQP] */ 
  bool RelaxCon;

 /* scaled objective function */ 
  bool scaledObj;

 /* scaled QP */ 
  bool scaledQP;

 /* weakactiveset is allowed to set constraint to inactive */ 
  bool setInactive;

 /* MinimumStepsize hit during TakeQPSol */ 
  bool TakeQPSolError;

 /* Use identity matrix in QP? */ 
  bool UseId;

 /* Indicates if the last iteration was in Feasible Mode */ 
  bool WasFeasMode;

 /* Current point acceptable to filter? */ 
  bool Acceptable;

 /* AresForce applicable? (don't do it when no search direction is calculated yet) */ 
  bool AresForce;

 /* Augment filter after accelerating heuristic (ignore criteria)? */ 
  bool AugmentFilter;

 /* Check full stepsize (accelerating heuristic: ignore criteria)? */ 
  bool CheckFullStepsize;

 /* Feasibility restoration invoked? */ 
  bool FeasRest;

 /* Is it the first Hessian regularization? */ 
  bool FirstHessianReg;

 /* Accept full stepsize in next iteration? */ 
  bool FullStepsize;

 /* Step size is an f-step-size? */ 
  bool FStepsize;

 /* Last unsuccessful trial stepsize rejected because of the filter? */ 
  bool RejectedByFilter;

 /* Is it the second Hessian regularization? */ 
  bool SecondHessianReg;

 /* SLP step? */ 
  bool SLPstep;

 /* Accelerating heuristic (ignore criteria) unsuccessful? */ 
  bool SmallerAlpha;

 /* Switching condition satisfied? */ 
  bool SwitchingCond;

 /* Debug marker. Used to find memory alignment/padding issues */ 
  int DebugMarker04;

 /* Automatically added initialisation flag.  */
  bool initialised;
} Workspace;

typedef struct ParamsStruct {

 /* Pointer to QP parameter structure */ 
  QPParams qp;

 /* Debug marker. Used to find memory alignment/padding issues */ 
  int DebugMarker05;

 /*------------------------------------------------ 
  *  Real parameters
  *------------------------------------------------ */ 

 /* Tolerance for acceptable feasibility */ 
  double AcceptTolFeas;

 /* Tolerance for acceptable optimality */ 
  double AcceptTolOpti;

 /* Trial stepsize decrease factor for Armijo rule */ 
  double ArmijoBeta;

 /* Initial alpha for Armijo rule */ 
  double ArmijoMaxAlpha;

 /* Lower bound on alpha for Armijo rule */ 
  double ArmijoMinAlpha;

 /* Lower bound on alpha for Armijo rule during recovery */ 
  double ArmijoMinAlphaRec;

 /* Scale factor for linearised descent check in Armijo rule */ 
  double ArmijoSigma;

 /* Update factor for Betts' Hessian regularisation */ 
  double BettsFactor;

 /* Smallest eigenvalue of the regularised Hessian */ 
  double BettsPoint;

 /* Factor in determining active constraints by KKT */ 
  double BoundTolFac;

 /* (experimental) */ 
  double CorStepBettsSum;

 /* (experimental) */ 
  double CorStepConvio;

 /* (experimental) */ 
  double CorStepConStop;

 /* (experimental) */ 
  double CorStepPFactor;

 /* (experimental) */ 
  double CorStepPMax;

 /* Upper bound used by Fritz-John heuristic */ 
  double CheckFJ;

 /* Block BFGS curvature condition bound */ 
  double CurvBCond;

 /* Block BFGS curvature condition regularisation factor */ 
  double CurvBFac;

 /* BFGS Curvature condition bound */ 
  double CurvCond;

 /* BFGS curvature condition regularisation factor */ 
  double CurvFac;

 /* Feasibility tolerance for no-objective feasible mode */ 
  double FeasibleInitTol;

 /* Finite difference perturbation */ 
  double FidifEps;

 /* Factor in Focus-on-Feasibility mode */ 
  double FocusOnFeasFactor;

 /* Upper bound for numbers to be regarded as finite */ 
  double Infty;

 /* Tolerance for unboundedness detection heuristic */ 
  double InftyUnbounded;

 /* IP complementarity tolerance in initial multiplier estimate */ 
  double LMestQPipComTol;

 /* IP residual tolerance in initial multiplier estimate */ 
  double LMestQPipResTol;

 /* Lowpass-filter update factor for objective values */ 
  double LowPassAlphaF;

 /* Lowpass-filter update factor for constraint values */ 
  double LowPassAlphaG;

 /* Lowpass-filter update factor for merit function values */ 
  double LowPassAlphaMerit;

 /* Any pivot whose modulus is less than this is treated as zero by MA97 */ 
  double MA97small;

 /* Relative pivot tolerance of MA97 */ 
  double MA97u;

 /* Threshold of meritfunction gradient for increasing Hessian regularisation */ 
  double MeritGradTol;

 /* Penalty update parameter factor for MeritFunction = 4 */ 
  double PenUpdEpsKFac;

 /* Penalty update parameter factor for MeritFunction = 3 */ 
  double PenUpdEpsBar;

 /* Max penalty for MeritFunction = 4 */ 
  double PenUpdMaxDeltaK;

 /* Max factor for increasing penalty for MeritFunction = 4 */ 
  double PenUpdMaxFac;

 /* Penalty update parameter for MeritFunction = 3 */ 
  double PenUpdRBar;

 /* (currently unused) Relative precision of objective */ 
  double PrecisionF;

 /* (currently unused) Relative precision of constraints */ 
  double PrecisionG;

 /* (currently unused) Scaling factor for QP */ 
  double QPscaleParam;

 /* Upper bound for accepting the constraint relaxation variable */ 
  double RelaxMaxDelta;

 /* Upper bound on the constraint relaxation penalty */ 
  double RelaxMaxPen;

 /* Update factor for the constraint relaxation penalty */ 
  double RelaxRho;

 /* Initial value of the constraint relaxation penalty */ 
  double RelaxStart;

 /* Value to scale large objective functions to */ 
  double ScaleFacObj;

 /* Upper bound on resulting matrix norm for QP scaling */ 
  double ScaleFacQP;

 /* Initial value for Betts' update dampening term */ 
  double StartBettsTau;

 /* Timeout in seconds */ 
  double Timeout;

 /* Complementarity tolerance */ 
  double TolComp;

 /* Feasibility tolerance */ 
  double TolFeas;

 /* Optimality tolerance */ 
  double TolOpti;

 /* (experimental) */ 
  double TolWeakActive;

 /* Upper bound on constraint violation for too-big heuristic */ 
  double TooBigCV;

 /* Upper bound on KKT values for too-big heuristic */ 
  double TooBigKKT;

 /* Machine epsilon */ 
  double eps;

 /* Increase factor for estimated integer workspace requirement */ 
  double IncreaseIWS;

 /* Increase factor for estimated real workspace requirement */ 
  double IncreaseRWS;

 /* Constraint violation decrease factor in Filter acceptance check */ 
  double FilterGammaCV;

 /* Objective decrease factor in Filter acceptance check */ 
  double FilterGammaF;

 /* Safety factor for alphamin calculation by Filter */ 
  double GammaAlpha;

 /* Increase factor for Betts' update dampening term */ 
  double IncBettsTau;

 /* Larger increase factor for Betts' update dampening term */ 
  double IncBettsTauMore;

 /* Lower bound for Betts' update dampening term */ 
  double MinBettsTau;

 /* Decrease factor for Betts' update dampening term */ 
  double ReduceBettsTau;

 /* Start tolerance for successful termination of iterative refinement due to perturbation in constraints */ 
  double RefineStartTol;

 /* Maximum allowed relaxation to apply feasibility refinement */ 
  double RefineMaxRelax;

 /* Maximum allowed regularisation of the hessian CAUTION absolute value */ 
  double RefineMaxHMReg;

 /* Filter switching condition parameter */ 
  double SwitchingDelta;

 /* Filter switching condition parameter */ 
  double SwitchingSF;

 /* Filter switching condition parameter */ 
  double SwitchingSCV;

 /*------------------------------------------------ 
  *  Integer parameters
  *------------------------------------------------ */ 

 /* Armijo recovery strategies */ 
  int Ares[NAres];

 /* Choose BFGS method (0: dense, 1-3: block, 100+: sparse) */ 
  int BFGSmethod;

 /* Restart BFGS update after this many iterations */ 
  int BFGSrestart;

 /* Block size parameter used by certain BFGS methods */ 
  int BFGSmaxblockSize;

 /* Block size parameter used by certain BFGS methods */ 
  int BFGSminblockSize;

 /* (experimental) */ 
  int CorStepMaxIter;

 /* (experimental) */ 
  int CorStepMethod;

 /* (experimental) */ 
  int CorStepMode;

 /* Select method to determine graph colouring groups */ 
  int GroupMethod;

 /* Enable XML logfiles and writing interval */ 
  int LogLevel;

 /* Enable XML result logging and detail level */ 
  int LogResult;

 /* Ordering used by MA97 */ 
  int MA97ordering;

 /* Scaling used by MA97 */ 
  int MA97scaling;

 /* Print level used by MA97 */ 
  int MA97print;

 /* Node amalgation, controls merging in elimination tree by MA97 */ 
  int MA97nemin;

 /* Upper bound to Reverse Communication calls */ 
  int MaxCalls;

 /* Maximum number of Force recovery strategy steps */ 
  int MaxForce;

 /* (experimental) */ 
  int MaxGPart;

 /* Upper bound on major iterations */ 
  int MaxIter;

 /* Select merit function and penalty update [0, 3..5] */ 
  int MeritFunction;

 /* Select (1) Meritfunction or (3) Filter globalisation */ 
  int NLPmethod;

 /* NLP print level [-1..4] */ 
  int NLPprint;

 /* Select method to determine graph colouring pairgroups */ 
  int PairMethod;

 /* Penalty update parameter */ 
  int PenUpdEpsKSequence;

 /* Enable automatic Hessian structure generation or checking */ 
  int UserHMstructure;

 /* Control activation of Filter acceleration heuristics */ 
  int MaxLScounter;

 /* Select Hessian regularisation strategy in Filter */ 
  int RegStrategy;

 /*------------------------------------------------ 
  *  Logical parameters
  *------------------------------------------------ */ 

 /* Enable automatic QP recovery */ 
  bool AutoQPRecovery;

 /* Enable structural checking of DF */ 
  bool CheckStructureDF;

 /* Enable structural checking of DG */ 
  bool CheckStructureDG;

 /* Enable structural checking of HM */ 
  bool CheckStructureHM;

 /* (experimental) */ 
  bool CorStepRecoveryDX;

 /* F and G cannot be evaluated separately */ 
  bool FGtogether;

 /* Enable Fritz-John and non-differentiable check heuristics */ 
  bool FJandND;

 /* Activate dual feasibility mode */ 
  bool FeasibleDual;

 /* Activate initial feasibility mode */ 
  bool FeasibleInit;

 /* Activate feasible-only mode */ 
  bool FeasibleOnly;

 /* Approximate Hessian by finite differences (otherwise BFGS) */ 
  bool FidifHM;

 /* Use central finite difference quotient for first derivatives */ 
  bool FirstDifCentral;

 /* Enable Focus-on-Feasibility mode */ 
  bool FocusOnFeas;

 /* Enable initial Lagrange multiplier estimate */ 
  bool InitialLMest;

 /* Save acceptable solutions as fallback */ 
  bool KeepAcceptableSol;

 /* Control Lagrange multiplier update */ 
  bool LinMult;

 /* Enable lowpass-filter termination criterion */ 
  bool LowPassFilter;

 /* Use BLAS level 3 (dgemm) in MA97 */ 
  bool MA97blas3;

 /* Use multifrontal-style forward solve of MA97 */ 
  bool MA97mf;

 /* Not to be included into a parameter file! */ 
  bool MatrixCC;

 /* Introduce one relaxation variable for every constraint */ 
  bool MoreRelax;

 /* Not to be included into a parameter file! */ 
  bool QuadraticProblem;

 /* Activates iterative refinement due to perturbation in constraints using parametric sensitivities */ 
  bool RefineFeasibility;

 /* Activates new iterative refinement of constraints only when Armijo alpha equals one */ 
  bool RefineOnlyOnAlpha;

 /* Do restoration until a feasible solution is found */ 
  bool RestUntilFeas;

 /* Scale constraints in every iteration */ 
  bool ScaleConIter;

 /* Use a scaled perturbation for finite differences */ 
  bool ScaledFD;

 /* Scale KKT conditions */ 
  bool ScaledKKT;

 /* Scale the objective function */ 
  bool ScaledObj;

 /* Scale some matrices handed to the QP */ 
  bool ScaledQP;

 /* Evaluate QP search direction regardless of convergence */ 
  bool TakeQPSol;

 /* Enable too-big termination heuristics */ 
  bool TooBig;

 /* Activates update of lagrange multipliers during correction step */ 
  bool UpdateMu;

 /* Objective gradient values supplied by caller */ 
  bool UserDF;

 /* Jacobian values supplied by caller */ 
  bool UserDG;

 /* Hessian values supplied by caller */ 
  bool UserHM;

 /* Hessian values supplied by caller */ 
  bool UserZenDGp;

 /* Hessian values supplied by caller */ 
  bool UserZenDLxp;

 /* Gradient values supplied by caller */ 
  bool UserZenDLp;

 /* Hessian values supplied by caller */ 
  bool UserZenDLpp;

 /* Run Zen module after successful termination */ 
  bool UseZen;

 /* Check maximum of secure perturbation when updating solution */ 
  bool ZenCheckMaxPert;

 /* false: use LU from last QP step; true: renew LU decomposition. */ 
  bool ZenRenewLU;
  bool ZenFDnewMethod;

 /* (experimental) */ 
  bool WeakActiveSet;

 /* Use a constant lower bound on Armijo stepsize in Filter */ 
  bool AlphaMinConst;

 /* Activate accelerating heuristics for Filter */ 
  bool IgnoreFilterCrit;

 /* Filter heuristic to save Armijo iterations */ 
  bool FilterBisecAlpha;

 /* Filter heuristic to save Armijo iterations */ 
  bool FilterIntersecAlpha;

 /* Select max-norm instead of 1-norm in Filter */ 
  bool MaxNorm;

 /* Enables Filter-reinitialisation accelerating heuristic */ 
  bool ReinitFilter;

 /* Debug marker. Used to find memory alignment/padding issues */ 
  int DebugMarker06;

 /* Counter for changed parameters. Internal use only. */ 
  int internalParChanged;

 /* Automatically added initialisation flag.  */
  bool initialised;
} Params;

typedef struct ControlStruct {
  DateType Date;
  TimerType Timer;

 /* Ring buffer for stage history */ 
  int Stage[NStageHistory];

 /* Logical field for user action flags */ 
  bool UserAction[NUserAction];

 /* External status flag */ 
  int status;

 /* Internal status flag */ 
  int int_status;

 /* WORHP status cached by Zen */ 
  int pre_zen_status;
  int currentStage;

 /* Counter for Zen loops with Reverse Communication */ 
  counter ZenRCcounter1;

 /* Counter for Zen loops with Reverse Communication */ 
  counter ZenRCcounter2;

 /* True if Zen has been initialised. */ 
  bool ZenInit;

 /* Automatically added initialisation flag.  */
  bool initialised;
} Control;

/* These prototypes are only present to give them the
 * DLL_PRIVATE attribute, which is not available in gfortran. */
DLL_PRIVATE int Internal_InitOptVar(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Internal_FreeOptVar(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int CheckOptVar(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Auto_CheckOptVar(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Internal_InitWorkspace(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Internal_FreeWorkspace(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int CheckWorkspace(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Auto_CheckWorkspace(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Internal_InitParams(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Internal_FreeParams(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int CheckParams(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Auto_CheckParams(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Internal_InitControl(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Internal_FreeControl(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int CheckControl(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);
DLL_PRIVATE int Auto_CheckControl(OptVar *opt, Workspace *wsp, Params *par, Control *cnt);

/* Defined in Worhp_Data.F90 via C-interop  */
DLL_PUBLIC bool GetUserAction(const Control *cnt, int action);
DLL_PUBLIC void DoneUserAction(Control *cnt, int done);
DLL_PUBLIC void AddUserAction(Control *cnt, int add);
DLL_PUBLIC void SetNextStage(Control*, int);
DLL_PUBLIC int  GetCurrentStage(Control*);
DLL_PUBLIC int  GetPreviousStage(Control*, int);

/* Defined in C_Worhp_Data.c  */
DLL_PUBLIC void WorhpVersion(int *major, int *minor, char (*patch)[PATCH_STRING_LENGTH]);
DLL_PUBLIC int CheckWorhpVersion(int major, int minor, const char *patch);
DLL_PRIVATE size_t MinRWS(OptVar*, Workspace*, Params*, Control*);
DLL_PRIVATE size_t MinIWS(OptVar*, Workspace*, Params*, Control*);

#endif /* HEADER_C_WORHP_DATA_H_GUARD */


